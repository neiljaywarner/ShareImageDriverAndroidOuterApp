```markdown
# README_IOS.md: iOS Host App (Swift) with Flutter Module Integration

This document describes how to integrate the `receive_images_flutter_demo` Flutter module into a new native iOS application written in Swift. This guide uses the XCFrameworks generated by Flutter and CocoaPods for dependency management.

**Goal:** To create a simple Swift iOS app that can launch the Flutter module and receive image data (URIs/paths) from the iOS host via Pigeon.

## Prerequisites

-   **macOS:** Required for iOS development.
-   **Xcode:** Latest stable version (e.g., from the Mac App Store).
-   **Flutter SDK:** Latest stable channel version. Ensure it's correctly installed and configured.
-   **CocoaPods:** Ruby gem for managing iOS project dependencies. Install/update via `sudo gem install cocoapods`.
-   **An Apple Developer Account:** May be needed for running on a physical device, but simulators can be used.
-   **Git:** For cloning the Flutter module repository.

## Setup Instructions

### 1. Clone the Flutter Module Repository (`receive_images_flutter_demo`)

If you haven't already, clone the Flutter module.

```bash
# Navigate to your preferred projects directory
cd ~/Projects # Or your chosen directory, e.g., ~/AndroidStudioProjects

# Clone the Flutter module repository
# Replace YOUR_USERNAME/receive_images_flutter_demo.git with the actual URL
git clone https://github.com/YOUR_USERNAME/receive_images_flutter_demo.git
```

### 2. Build the Flutter Module as an XCFramework

1. **Navigate to the Flutter module directory:**
   ```bash
   cd receive_images_flutter_demo 
   ```

2. **Ensure Flutter SDK is healthy:**
   ```bash
   flutter doctor -v
   ```

3. **Get Flutter dependencies:**
   ```bash
   flutter pub get
   ```

4. **Generate Pigeon communication files (including Swift output):**
   This step is crucial for creating the Swift interface code.
   ```bash
   flutter pub run pigeon --input pigeons/image_messages.dart --dart_out lib/pigeon.dart --java_out ./.android/app/src/main/java/com/example/receive_images_flutter_demo/Pigeon.java --java_package com.example.receive_images_flutter_demo --swift_out .ios/Runner/Pigeon.swift
   ```
    * This command should generate `Pigeon.swift` (and potentially `Pigeon.h`/`.m` if Objective-C
      output was also specified and needed by Swift) inside the `.ios/Runner/` directory of your
      Flutter module.

5. **Build the XCFrameworks:**
   We'll create a directory to hold the frameworks, for example, in a shared location or directly
   within your planned iOS host app project structure later.
   ```bash
   # Example: Output frameworks to a specific directory
   # You might adjust this path to be relative to your iOS host app later
   flutter build ios-framework --xcframework --cocoapods --output=../FlutterModuleBuilds/ios_module/FlutterModule
   ```
    * This command builds Debug, Profile, and Release versions of `App.xcframework` and
      `Flutter.xcframework`, along with a `Flutter.podspec` file, into the specified output
      directory (`../FlutterModuleBuilds/ios_module/FlutterModule` in this example). **Remember this
      output path.**

### 3. Create a New Swift iOS Application in Xcode

1. **Open Xcode.**
2. **Create a new project:** File > New > Project...
3. **Select the iOS tab.**
4. **Choose the "App" template** (under Application) and click Next.
5. **Product Name:** e.g., `MySwiftImageReceiver`
6. **Team:** Select your team (or None/Personal Team).
7. **Interface:** SwiftUI or Storyboard (SwiftUI is more modern, but either works).
8. **Language:** Swift.
9. **Life Cycle:** SwiftUI App or UIKit App Delegate (depends on Interface choice).
10. **Click Next**, choose a location to save your iOS project (e.g.,
    `~/Projects/MySwiftImageReceiver`), and click Create.

### 4. Integrate Flutter Module using CocoaPods

1. **Close your newly created Xcode project.**

2. **Open your terminal and navigate to the root directory of your new iOS project:**
   ```bash
   cd ~/Projects/MySwiftImageReceiver # Or wherever you saved it
   ```

3. **Initialize CocoaPods for your project (if you don't have a `Podfile` already):**
   ```bash
   pod init
   ```
   This will create a `Podfile` in your project directory.

4. **Edit the `Podfile`:**
   Open the `Podfile` in a text editor. You need to tell CocoaPods where to find the Flutter
   module's `Flutter.podspec`.

   Modify your `Podfile` to look something like this (adjust paths as necessary):

   ```ruby
   # platform :ios, '12.0' # Or your desired deployment target

   target 'MySwiftImageReceiver' do # Replace with your actual app target name
     use_frameworks!

     # Path to the directory containing Flutter.podspec generated by `flutter build ios-framework`
     # This path should point to the Debug, Profile, or Release folder chosen for your build configuration.
     # For simplicity in development, you might start with Debug.
     # For production, you'd use Release.
     # Ensure this path is correct relative to your iOS project's Podfile.
     # The directory structure from our build command was: ../FlutterModuleBuilds/ios_module/FlutterModule/[Debug|Profile|Release]/Flutter.podspec
     pod 'Flutter', :podspec => '../FlutterModuleBuilds/ios_module/FlutterModule/Debug/Flutter.podspec' 
     # Or for release: 
     # pod 'Flutter', :podspec => '../FlutterModuleBuilds/ios_module/FlutterModule/Release/Flutter.podspec' 

     # If your Flutter module has plugins with iOS native code, they might be listed here too
     # or handled by the Flutter.podspec itself.
   end
   ```
    * **Important:** The path to the `.podspec` file is critical. Adjust
      `../FlutterModuleBuilds/ios_module/FlutterModule/Debug/Flutter.podspec` based on where you
      outputted the Flutter frameworks and which build type (Debug/Profile/Release) you intend to
      use. Using a relative path is common if you structure your projects in a known way (e.g.,
      Flutter module and iOS host app as siblings).

5. **Install the pods:**
   ```bash
   pod install --repo-update # --repo-update is good practice
   ```
    * This will download Flutter engine artifacts and configure your project.
    * If successful, it will create a `.xcworkspace` file (e.g.,
      `MySwiftImageReceiver.xcworkspace`).

6. **Open the `.xcworkspace` file in Xcode from now on:**
    * Do NOT open the `.xcodeproj` file anymore. Always use the `.xcworkspace` for projects with
      CocoaPods.
   ```bash
   open MySwiftImageReceiver.xcworkspace
   ```

### 5. Add Pigeon-Generated Swift File to Xcode Project

1. In Xcode, right-click on your main project group (e.g., `MySwiftImageReceiver` group) in the
   Project Navigator.
2. Select "Add Files to "MySwiftImageReceiver"...".
3. Navigate to your Flutter module directory:
   `~/AndroidStudioProjects/receive_images_flutter_demo/.ios/Runner/`.
4. Select `Pigeon.swift` (this was generated by the `flutter pub run pigeon ... --swift_out ...`
   command).
5. Ensure "Copy items if needed" is **checked**.
6. Ensure your app target is selected in "Add to targets".
7. Click "Add".
    * Xcode might ask if you want to create an Objective-C Bridging Header if this is the first
      Swift/Obj-C interaction. Click "Create Bridging Header" if prompted (though for pure Swift
      Pigeon, it might not be strictly necessary, it's often useful for general Flutter plugin
      compatibility).

### 6. Implement Pigeon Host API in Swift

1. **Create a Swift class to handle Pigeon communication.**
   For example, create a new Swift file named `ImageApiHandler.swift` (File > New > File... > Swift
   File).

2. **Implement the `ImageHostApi` protocol (defined in `Pigeon.swift`):**

   ```swift
   // ImageApiHandler.swift
   import Foundation
   // If your Flutter module name is different, the import might change
   // Or if Pigeon.swift is directly in your target, you might not need an explicit import here.

   class ImageApiHandler: NSObject, ImageHostApi {
       // Store the image data that would be "shared" to this app
       // In a real app, this would come from an intent handler, photo picker, etc.
       var sharedImageData: [ImageData] = []

       // Singleton for easy access if needed, or manage instance differently
       static let shared = ImageApiHandler()

       private override init() { 
           super.init()
           // Simulate some initial image data for testing
           // In a real app, this would be populated dynamically
           let image1 = ImageData(uri: "file:///example/path/to/image1.jpg", mimeType: "image/jpeg")
           let image2 = ImageData(uri: "content://example/image2.png", mimeType: "image/png")
           self.sharedImageData = [image1, image2]
       }

       func getSharedImages() throws -> [ImageData] {
           // In a real share extension or app, you would process incoming intents/data here
           // and convert them into a list of ImageData objects.
           print("ImageHostApi: getSharedImages() called by Flutter.")
           return self.sharedImageData 
       }
       
       // Call this method from your app when new images are shared to update the data
       public func updateSharedImages(newImages: [ImageData]) {
           self.sharedImageData = newImages
           print("ImageHostApi: Updated shared images. Count: \(newImages.count)")
       }
   }
   ```

3. **Set up the Pigeon API handler in your `AppDelegate.swift` (or your main app struct if using
   SwiftUI App life cycle):**

   If using UIKit App Delegate (`AppDelegate.swift`):
   ```swift
   import UIKit
   import Flutter
   // Make sure Pigeon.swift is part of your target so ImageHostApi is recognized

   @main
   class AppDelegate: UIResponder, UIApplicationDelegate {

       var window: UIWindow?
       lazy var flutterEngine = FlutterEngine(name: "my_flutter_engine")

       func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
           // Start the Flutter engine.
           flutterEngine.run()

           // Set up Pigeon ImageHostApi
           let imageApiHandler = ImageApiHandler.shared // Or your instance
           ImageHostApiSetup.setUp(binaryMessenger: flutterEngine.binaryMessenger, api: imageApiHandler)
           
           // Example: If app launched from a share extension or URL, process here and update ImageApiHandler
           // self.handleIncomingShare(launchOptions: launchOptions) 

           return true
       }

       // ... other AppDelegate methods
   }
   ```

   If using SwiftUI App life cycle (`YourAppNameApp.swift`):
   You'll need to manage the FlutterEngine and Pigeon setup slightly differently, often involving an
   `UIApplicationDelegateAdaptor`.

   ```swift
   // YourAppNameApp.swift
   import SwiftUI
   import Flutter

   // Create a class that conforms to UIApplicationDelegate to handle Flutter setup
   class AppDelegateAdaptor: NSObject, UIApplicationDelegate {
       lazy var flutterEngine = FlutterEngine(name: "my_flutter_engine_swiftui")

       func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil) -> Bool {
           flutterEngine.run()
           
           let imageApiHandler = ImageApiHandler.shared
           ImageHostApiSetup.setUp(binaryMessenger: flutterEngine.binaryMessenger, api: imageApiHandler)
           print("Flutter Engine and Pigeon ImageHostApi Set Up (SwiftUI)")
           return true
       }
   }

   @main
   struct MySwiftImageReceiverApp: App {
       // Use UIApplicationDelegateAdaptor to hook into app lifecycle events for setup
       @UIApplicationDelegateAdaptor(AppDelegateAdaptor.self) var appDelegate

       var body: some Scene {
           WindowGroup {
               ContentView(flutterEngine: appDelegate.flutterEngine) // Pass engine to ContentView
           }
       }
   }
   ```

### 7. Launching the Flutter Screen

This depends on whether you are using UIKit or SwiftUI.

**For UIKit (e.g., in a `UIViewController`):**

```swift
import UIKit
import Flutter

class ViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // Example: Add a button to launch Flutter
        let button = UIButton(type: .system)
        button.setTitle("Open Flutter Module", for: .normal)
        button.addTarget(self, action: #selector(showFlutter), for: .touchUpInside)
        button.frame = CGRect(x: 50, y: 100, width: 200, height: 50)
        self.view.addSubview(button)
    }

    @objc func showFlutter() {
        guard let appDelegate = UIApplication.shared.delegate as? AppDelegate else {
            print("Error: Could not get AppDelegate")
            return
        }
        let flutterViewController = FlutterViewController(engine: appDelegate.flutterEngine, nibName: nil, bundle: nil)
        present(flutterViewController, animated: true, completion: nil)
    }
}
```

**For SwiftUI (e.g., in `ContentView.swift`):**

```swift
// ContentView.swift
import SwiftUI
import Flutter

// Create a struct to represent the FlutterViewController as a SwiftUI View
struct FlutterView: UIViewControllerRepresentable {
    var flutterEngine: FlutterEngine

    func makeUIViewController(context: Context) -> FlutterViewController {
        return FlutterViewController(engine: flutterEngine, nibName: nil, bundle: nil)
    }

    func updateUIViewController(_ uiViewController: FlutterViewController, context: Context) {
        // Optional: anny updates if needed
    }
}

struct ContentView: View {
    var flutterEngine: FlutterEngine // Receive the engine
    @State private var showFlutterView = false

    var body: some View {
        VStack {
            Image(systemName: "swift") // Example SwiftUI content
                .resizable()
                .scaledToFit()
                .frame(width: 100, height: 100)
            Text("Hello from Swift Host App!")
            
            Button("Open Flutter Module") {
                self.showFlutterView = true
            }
        }
        .sheet(isPresented: $showFlutterView) {
            FlutterView(flutterEngine: flutterEngine)
                .ignoresSafeArea() // Optional: to make it full screen
        }
        // To test image update, you could add a button here that calls:
        // Button("Simulate New Share") {
        //     let newImage = Pigeon_ImageData.Builder()
        //         .setUri("file:///new_image.jpg")
        //         .setMimeType("image/jpeg")
        //         .build()
        //     ImageApiHandler.shared.updateSharedImages(newImages: [newImage])
        // }
    }
}
```

### 8. Build and Run the iOS App

1. In Xcode, select your target device (simulator or physical device).
2. Click the Run button (or Product > Run).
3. The iOS app should launch.
4. When you trigger the action to show Flutter (e.g., tap the button), the Flutter screen should
   appear.
5. The Flutter screen will call `getSharedImages()` via Pigeon, and your
   `ImageApiHandler.getSharedImages()` in Swift will be executed, providing the (currently
   simulated) image data to Flutter.

## How it Works (iOS)

- The Flutter module is built as an XCFramework.
- CocoaPods is used to link this framework and the Flutter engine into your native iOS Swift
  project.
- Pigeon generates a `Pigeon.swift` file that defines the `ImageHostApi` protocol (for the native
  side to implement) and an `ImageFlutterApi` class (for the native side to call Flutter, not used
  extensively in this direction for this example).
- Your Swift code (`ImageApiHandler`) implements the `ImageHostApi` protocol.
- In your `AppDelegate` (or equivalent), you set up the Pigeon channel, associating the
  `ImageHostApi` protocol with your `ImageApiHandler` instance.
- When you launch a `FlutterViewController`, the Flutter Dart code can use its `ImageHostApi` client
  to make calls. These calls are routed over the platform channel by Pigeon to your Swift
  `ImageApiHandler` implementation.
- The results are returned to Flutter.

## Troubleshooting (iOS)

- **Flutter module not found / Pod install fails:**
    * Double-check the path to `Flutter.podspec` in your `Podfile`. It must be correct relative to
      the `Podfile`'s location.
    * Ensure `flutter build ios-framework ...` completed successfully and the specified output
      directory contains the `.podspec` and XCFrameworks.
    * Run `pod deintegrate` then `pod install --repo-update` in your iOS project directory.
- **`Pigeon.swift` or `ImageHostApi` not found:**
    * Ensure `Pigeon.swift` was correctly added to your app target in Xcode (Build Phases > Compile
      Sources).
    * Make sure `flutter pub run pigeon ... --swift_out ...` was run and generated the file
      correctly.
    * Clean the Xcode build folder (Product > Clean Build Folder) and rebuild.
- **Pigeon calls from Flutter don't seem to reach Swift, or vice-versa:**
    * Verify `ImageHostApiSetup.setUp(...)` is called in your `AppDelegate` with the correct binary
      messenger from your `FlutterEngine` instance and an instance of your `ImageHostApi`
      implementor.
    * Ensure the `FlutterEngine` is running before you try to present a `FlutterViewController` that
      uses it.
    * Use `print()` statements in both your Swift `ImageHostApi` methods and in your Flutter
      `ImageHostApi` calls to trace execution.
- **App crashes when launching FlutterViewController:**
    * Check Xcode console for error messages. Often related to engine setup or mismatched
      architectures if not using XCFrameworks correctly.
    * Ensure the `FlutterEngine` is properly initialized and run.

This guide provides a comprehensive starting point. Real-world share extensions or complex data
passing might require more intricate native iOS code to capture and forward the data to
`ImageApiHandler` before Flutter requests it.

```